Strängmatching
	∙ KMP (knuth–morris–prat)
	∙ Suffixsortering
	(∙ Aho-Corasick)
--------------------------------


Strängmatching
--------------

Givet mönster P = p₁p₂…p_m
Text  	      T = t₁…t_n
Hitta alla förekomster av P i T (det vill säga i så att t_i = p₁, t_{i+1} = p₂ … t_{i+m−1} = p_m)


Naiv algorithm

for i from 1 to n − m + 1
    match ← true
    for j from 1 to m
    	if p_j ≠ t_{i+j−1} then
	    match ← false
	    break
    if match then
        report i

Tid 𝓞(n⋅m) = 𝓞(n²)


Grundidé för snabbare algorithm: ändlig automat

Exemple möster p = ”popup”

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5

text T =  ”topupopup”
tillstånd 0001012345
                   ↓
		   matchning!

text T =  ”popopup”
tillstång  0122345

Automaten beskrivs ab övergångsfunction

	  next(i, c) = nästa tillstånd from tillstånd i om vi läser tecken c

Bra: Givet atutomaten är det lätt att göra strängsökning i 𝓞(n).

Dåligt: Om mönstret är över stort alfabete tar automaten mycket minne.


Mer minneseffektivt (ε-övergångar [tomma strängen])

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5
	  	 ↑                 |
		  \_______________/
			  ε


                       ________			   __________________
	              /	  x			  /         x
               x     ↓			==>	 ↓     x
	i−1 -------> i ------->			i-1 -------> i ------->


En bakåtpekar på nod

π[i] = största j så att p_i…p_j = p_{i−j+1}…p_i
(längsta prefix av P som är ett suffix av det vi hittills matchat)
	 	     	    	       	      	 	  ”−1”

               (π som i [p]refix)


Sökning givet π
---------------

Search(T, P, π)

    state ← 0
    for i from i to n
    	while state > 0 andd t_i ≠ P_{state − 1}
	    state ← π[state]
	if P_{state+1} = t_i
	    state ← state + 1
	if state = m then
	    report matchning ending at i

Tid för sökning:

    ∙ varje iteration tar vi (minst) ett steg bakåt
    ∙ totalt antal steg bakåt ≤ totalt antal steg framåt ≤ n

    ∴  𝓞(n)


När vi beräknat π[1…i−1] och vill beräkna π[i]
är det som om vi söker efter p₁…π[i−1] i p₁…p_i.


MakePrefix(P)

    state ← 0
    π ← 0
    for i from 2 to m
    	while state > 0 and p_i ≠ P_{state+1}
	      state ← π[state]
	if p_i ≠ P_{state+1}
	    state ← state + 1
	π[c] ← state





Suffixsortering
===============


Suffixträd


En trie med alla suffix till en sträng

Exempel "ananas"

	<< bild 1 >>

Några tillämpningar

-- Vad är längsta delsträng
   som förekommer ≥ t gånger?

-- Hur många delsträngar av längd ℓ förekommer i både T och T'


Bra:	Givet trådet kan många intressanta problem lösas i linjär tid (i trädets storlek)

Dåligt:	Väldigt komplicerade algoritmer



Suffix-array


Sortera suffix i alfabetisk ordning

0: ananas ⎫
1: nanas  ⎪
2: anas   ⎬=> 0, 2, 4, 1, 3, 5
3: nas    ⎪
4: as     ⎪
5: s      ⎭


Tumregel: Allt man kan göra med ett suffixträd kan
	  också göras med en suffix-array, gat en
	  faktor log n långsammare.

