Strängmatching
	∙ KMP
	∙ Suffixsortering
	(∙ Aho-Corasick)
--------------------------------


Strängmatching
--------------

Givet mönster P = p₁p₂…p_m
Text  	      T = t₁…t_n
Hitta alla förekomster av P i T (det vill säga i så att t_i = p₁, t_{i+1} = p₂ … t_{i+m−1} = p_m)


Naiv algorithm

for i from 1 to n − m + 1
    match ← true
    for j from 1 to m
    	if p_j ≠ t_{i+j−1} then
	    match ← false
	    break
    if match then
        report i

Tid 𝓞(n⋅m) = 𝓞(n²)


Grundidé för snabbare algorithm: ändlig automat

Exemple möster p = ”popup”

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5

text T =  ”topupopup”
tillstånd 0001012345
                   ↓
		   matchning!

text T =  ”popopup”
tillstång  0122345

Automaten beskrivs ab övergångsfunction

	  next(i, c) = nästa tillstånd from tillstånd i om vi läser tecken c

Bra: Givet atutomaten är det lätt att göra strängsökning i 𝓞(n).

Dåligt: Om mönstret är över stort alfabete tar automaten mycket minne.


Mer minneseffektivt (ε-övergångar [tomma strängen])

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5
	  	 ↑                 |
		  \_______________/
			  ε


                       ________			   __________________
	              /	  x			  /         x
               x     ↓			==>	 ↓     x
	i−1 -------> i ------->			i-1 -------> i ------->


En bakåtpekar på nod

π[i] = största j så att p_i…p_j = p_{i−j+1}…p_i
(längsta prefix av P som är ett suffix av det vi hittills matchat)
	 	     	    	       	      	 	  ”−1”

               (π som i [p]refix)


Sökning givet π
---------------

Search(T, P, π)

    state ← 0
    for i from i to n
    	while state > 0 andd t_i ≠ P_{state − 1}
	    state ← π[state]
	if P_{state+1} = t_i
	    state ← state + 1
	if state = m then
	    report matchning ending at i

Tid för sökning:

    ∙ varje iteration tar vi (minst) ett steg bakåt
    ∙ totalt antal steg bakåt ≤ totalt antal steg framåt ≤ n

    ∴  𝓞(n)

