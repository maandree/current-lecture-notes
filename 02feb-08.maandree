StrÃ¤ngmatching
	âˆ™ KMP (knuthâ€“morrisâ€“prat)
	âˆ™ Suffixsortering
	(âˆ™ Aho-Corasick)
--------------------------------


StrÃ¤ngmatching
--------------

Givet mÃ¶nster P = pâ‚pâ‚‚â€¦p_m
Text  	      T = tâ‚â€¦t_n
Hitta alla fÃ¶rekomster av P i T (det vill sÃ¤ga i sÃ¥ att t_i = pâ‚, t_{i+1} = pâ‚‚ â€¦ t_{i+mâˆ’1} = p_m)


Naiv algorithm

for i from 1 to n âˆ’ m + 1
    match â† true
    for j from 1 to m
    	if p_j â‰  t_{i+jâˆ’1} then
	    match â† false
	    break
    if match then
        report i

Tid ğ“(nâ‹…m) = ğ“(nÂ²)


GrundidÃ© fÃ¶r snabbare algorithm: Ã¤ndlig automat

Exemple mÃ¶ster p = â€popupâ€

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5

text T =  â€topupopupâ€
tillstÃ¥nd 0001012345
                   â†“
		   matchning!

text T =  â€popopupâ€
tillstÃ¥ng  0122345

Automaten beskrivs ab Ã¶vergÃ¥ngsfunction

	  next(i, c) = nÃ¤sta tillstÃ¥nd from tillstÃ¥nd i om vi lÃ¤ser tecken c

Bra: Givet atutomaten Ã¤r det lÃ¤tt att gÃ¶ra strÃ¤ngsÃ¶kning i ğ“(n).

DÃ¥ligt: Om mÃ¶nstret Ã¤r Ã¶ver stort alfabete tar automaten mycket minne.


Mer minneseffektivt (Îµ-Ã¶vergÃ¥ngar [tomma strÃ¤ngen])

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5
	  	 â†‘                 |
		  \_______________/
			  Îµ


                       ________			   __________________
	              /	  x			  /         x
               x     â†“			==>	 â†“     x
	iâˆ’1 -------> i ------->			i-1 -------> i ------->


En bakÃ¥tpekar pÃ¥ nod

Ï€[i] = stÃ¶rsta j sÃ¥ att p_iâ€¦p_j = p_{iâˆ’j+1}â€¦p_i
(lÃ¤ngsta prefix av P som Ã¤r ett suffix av det vi hittills matchat)
	 	     	    	       	      	 	  â€âˆ’1â€

               (Ï€ som i [p]refix)


SÃ¶kning givet Ï€
---------------

Search(T, P, Ï€)

    state â† 0
    for i from i to n
    	while state > 0 andd t_i â‰  P_{state âˆ’ 1}
	    state â† Ï€[state]
	if P_{state+1} = t_i
	    state â† state + 1
	if state = m then
	    report matchning ending at i

Tid fÃ¶r sÃ¶kning:

    âˆ™ varje iteration tar vi (minst) ett steg bakÃ¥t
    âˆ™ totalt antal steg bakÃ¥t â‰¤ totalt antal steg framÃ¥t â‰¤ n

    âˆ´  ğ“(n)


NÃ¤r vi berÃ¤knat Ï€[1â€¦iâˆ’1] och vill berÃ¤kna Ï€[i]
Ã¤r det som om vi sÃ¶ker efter pâ‚â€¦Ï€[iâˆ’1] i pâ‚â€¦p_i.


MakePrefix(P)

    state â† 0
    Ï€ â† 0
    for i from 2 to m
    	while state > 0 and p_i â‰  P_{state+1}
	      state â† Ï€[state]
	if p_i â‰  P_{state+1}
	    state â† state + 1
	Ï€[c] â† state





Suffixsortering
===============


SuffixtrÃ¤d


En trie med alla suffix till en strÃ¤ng

Exempel "ananas"

	<< bild 1 >>

NÃ¥gra tillÃ¤mpningar

-- Vad Ã¤r lÃ¤ngsta delstrÃ¤ng
   som fÃ¶rekommer â‰¥ t gÃ¥nger?

-- Hur mÃ¥nga delstrÃ¤ngar av lÃ¤ngd â„“ fÃ¶rekommer i bÃ¥de T och T'


Bra:	Givet trÃ¥det kan mÃ¥nga intressanta problem lÃ¶sas i linjÃ¤r tid (i trÃ¤dets storlek)

DÃ¥ligt:	VÃ¤ldigt komplicerade algoritmer



Suffix-array


Sortera suffix i alfabetisk ordning

0: ananas â«
1: nanas  âª
2: anas   â¬=> 0, 2, 4, 1, 3, 5
3: nas    âª
4: as     âª
5: s      â­


Tumregel: Allt man kan gÃ¶ra med ett suffixtrÃ¤d kan
	  ocksÃ¥ gÃ¶ras med en suffix-array, gat en
	  faktor log n lÃ¥ngsammare.


Naiv algoritm ğ“(nÂ² log n)

Viktigt: kan inte explicit skapa alla n suffix


IdÃ©er:

âˆ™ Sortera pÃ¥ de 2â†‘k fÃ¶rsta tecknen.

    (k = 0, 1, 2, 3, â€¦, log n)

âˆ™ NÃ¤r vi sorterar pÃ¥ prefix av lÃ¤ngd 2â†‘k:

    -- Suffixen redan sorterade pÃ¥ de 2â†‘{kâˆ’1} fÃ¶rsta tecknen.
       Bildar grupper av suffix dÃ¤r 2â†‘{kâˆ’1} fÃ¶rsta tecknen Ã¤r
       identiska.

    -- Vi behÃ¶ver sortera varje grupp pÃ¥de 2â†‘{kâˆ’1} nÃ¤stfÃ¶ljande
       tecknen.
       Men fessa tecken Ã¤Ã¤r de 2â†‘{kâˆ’1} fÃ¶rsta fÃ¶r nÃ¥gra andra
       suffix; vi har redan deras ordning.


0: ananas â«    	2: a[n]as  â â«     2: an[as]  â â«     0: ananas)
1: nanas  âªk=0	4: a[s]    âŸ âªk=1  0: an[an]asâ  âªk=2  2: anas  )
2: anas   â¬==>  0: a[n]anasâ  â¬==>  4: as[  ]  ) â¬==>  4: as    ) klar, alla grupper
3: nas    âª	3: n[a]s   â âª     3: na[s ]  â âª     1: nanas ) bestÃ¥r av ett element
4: as     âª	1: n[a]nas â  âª     1: na[na]s â  âª     3: nas   )
5: s      â­	5: s[ ]    ) â­     5: s [  ]  ) â­     5: s     )


KÃ¶rtid

âˆ™ log n iterationer
âˆ™ i varje iteration sortera vi â‰¤ n element	ğ“(n log n) jÃ¤mfÃ¶relser
âˆ™ varje jÃ¤mfÃ¶relse kan gÃ¶ras i ğ“(1) tid
  genom att hÃ¥lla reda pÃ¥ vilken position varje suffix finns pÃ¥


Total tid: ğ“(n logÂ² n) 	  	 	  [logÂ² n = (log n)Â²]

Inte den snabbaste, men enkel.





