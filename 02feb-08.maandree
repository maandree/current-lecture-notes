StrÃ¤ngmatching
	âˆ™ KMP (knuthâ€“morrisâ€“prat)
	âˆ™ Suffixsortering
	(âˆ™ Aho-Corasick)
--------------------------------


StrÃ¤ngmatching
--------------

Givet mÃ¶nster P = pâ‚pâ‚‚â€¦p_m
Text  	      T = tâ‚â€¦t_n
Hitta alla fÃ¶rekomster av P i T (det vill sÃ¤ga i sÃ¥ att t_i = pâ‚, t_{i+1} = pâ‚‚ â€¦ t_{i+mâˆ’1} = p_m)


Naiv algorithm

for i from 1 to n âˆ’ m + 1
    match â† true
    for j from 1 to m
    	if p_j â‰  t_{i+jâˆ’1} then
	    match â† false
	    break
    if match then
        report i

Tid ğ“(nâ‹…m) = ğ“(nÂ²)


GrundidÃ© fÃ¶r snabbare algorithm: Ã¤ndlig automat

Exemple mÃ¶ster p = â€popupâ€

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5

text T =  â€topupopupâ€
tillstÃ¥nd 0001012345
                   â†“
		   matchning!

text T =  â€popopupâ€
tillstÃ¥ng  0122345

Automaten beskrivs ab Ã¶vergÃ¥ngsfunction

	  next(i, c) = nÃ¤sta tillstÃ¥nd from tillstÃ¥nd i om vi lÃ¤ser tecken c

Bra: Givet atutomaten Ã¤r det lÃ¤tt att gÃ¶ra strÃ¤ngsÃ¶kning i ğ“(n).

DÃ¥ligt: Om mÃ¶nstret Ã¤r Ã¶ver stort alfabete tar automaten mycket minne.


Mer minneseffektivt (Îµ-Ã¶vergÃ¥ngar [tomma strÃ¤ngen])

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5
	  	 â†‘                 |
		  \_______________/
			  Îµ


                       ________			   __________________
	              /	  x			  /         x
               x     â†“			==>	 â†“     x
	iâˆ’1 -------> i ------->			i-1 -------> i ------->


En bakÃ¥tpekar pÃ¥ nod

Ï€[i] = stÃ¶rsta j sÃ¥ att p_iâ€¦p_j = p_{iâˆ’j+1}â€¦p_i
(lÃ¤ngsta prefix av P som Ã¤r ett suffix av det vi hittills matchat)
	 	     	    	       	      	 	  â€âˆ’1â€

               (Ï€ som i [p]refix)


SÃ¶kning givet Ï€
---------------

Search(T, P, Ï€)

    state â† 0
    for i from i to n
    	while state > 0 andd t_i â‰  P_{state âˆ’ 1}
	    state â† Ï€[state]
	if P_{state+1} = t_i
	    state â† state + 1
	if state = m then
	    report matchning ending at i

Tid fÃ¶r sÃ¶kning:

    âˆ™ varje iteration tar vi (minst) ett steg bakÃ¥t
    âˆ™ totalt antal steg bakÃ¥t â‰¤ totalt antal steg framÃ¥t â‰¤ n

    âˆ´  ğ“(n)


NÃ¤r vi berÃ¤knat Ï€[1â€¦iâˆ’1] och vill berÃ¤kna Ï€[i]
Ã¤r det som om vi sÃ¶ker efter pâ‚â€¦Ï€[iâˆ’1] i pâ‚â€¦p_i.


MakePrefix(P)

    state â† 0
    Ï€ â† 0
    for i from 2 to m
    	while state > 0 and p_i â‰  P_{state+1}
	      state â† Ï€[state]
	if p_i â‰  P_{state+1}
	    state â† state + 1
	Ï€[c] â† state





Suffixsortering
===============


SuffixtrÃ¤d


En trie med alla suffix till en strÃ¤ng

Exempel "ananas"

	<< bild 1 >>

NÃ¥gra tillÃ¤mpningar

-- Vad Ã¤r lÃ¤ngsta delstrÃ¤ng
   som fÃ¶rekommer â‰¥ t gÃ¥nger?

-- Hur mÃ¥nga delstrÃ¤ngar av lÃ¤ngd â„“ fÃ¶rekommer i bÃ¥de T och T'


Bra:	Givet trÃ¥det kan mÃ¥nga intressanta problem lÃ¶sas i linjÃ¤r tid (i trÃ¤dets storlek)

DÃ¥ligt:	VÃ¤ldigt komplicerade algoritmer



Suffix-array


Sortera suffix i alfabetisk ordning

0: ananas â«
1: nanas  âª
2: anas   â¬=> 0, 2, 4, 1, 3, 5
3: nas    âª
4: as     âª
5: s      â­


Tumregel: Allt man kan gÃ¶ra med ett suffixtrÃ¤d kan
	  ocksÃ¥ gÃ¶ras med en suffix-array, gat en
	  faktor log n lÃ¥ngsammare.

