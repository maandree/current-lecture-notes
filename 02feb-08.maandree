Strängmatching
	∙ KMP (knuth–morris–prat)
	∙ Suffixsortering
	(∙ Aho-Corasick)
--------------------------------


Strängmatching
--------------

Givet mönster P = p₁p₂…p_m
Text  	      T = t₁…t_n
Hitta alla förekomster av P i T (det vill säga i så att t_i = p₁, t_{i+1} = p₂ … t_{i+m−1} = p_m)


Naiv algorithm

for i from 1 to n − m + 1
    match ← true
    for j from 1 to m
    	if p_j ≠ t_{i+j−1} then
	    match ← false
	    break
    if match then
        report i

Tid 𝓞(n⋅m) = 𝓞(n²)


Grundidé för snabbare algorithm: ändlig automat

Exemple möster p = ”popup”

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5

text T =  ”topupopup”
tillstånd 0001012345
                   ↓
		   matchning!

text T =  ”popopup”
tillstång  0122345

Automaten beskrivs ab övergångsfunction

	  next(i, c) = nästa tillstånd from tillstånd i om vi läser tecken c

Bra: Givet atutomaten är det lätt att göra strängsökning i 𝓞(n).

Dåligt: Om mönstret är över stort alfabete tar automaten mycket minne.


Mer minneseffektivt (ε-övergångar [tomma strängen])

	    p        o        p        u        p
	0 -----> 1 -----> 2 -----> 3 -----> 4 -----> 5
	  	 ↑                 |
		  \_______________/
			  ε


                       ________			   __________________
	              /	  x			  /         x
               x     ↓			==>	 ↓     x
	i−1 -------> i ------->			i-1 -------> i ------->


En bakåtpekar på nod

π[i] = största j så att p_i…p_j = p_{i−j+1}…p_i
(längsta prefix av P som är ett suffix av det vi hittills matchat)
	 	     	    	       	      	 	  ”−1”

               (π som i [p]refix)


Sökning givet π
---------------

Search(T, P, π)

    state ← 0
    for i from i to n
    	while state > 0 andd t_i ≠ P_{state − 1}
	    state ← π[state]
	if P_{state+1} = t_i
	    state ← state + 1
	if state = m then
	    report matchning ending at i

Tid för sökning:

    ∙ varje iteration tar vi (minst) ett steg bakåt
    ∙ totalt antal steg bakåt ≤ totalt antal steg framåt ≤ n

    ∴  𝓞(n)


När vi beräknat π[1…i−1] och vill beräkna π[i]
är det som om vi söker efter p₁…π[i−1] i p₁…p_i.


MakePrefix(P)

    state ← 0
    π ← 0
    for i from 2 to m
    	while state > 0 and p_i ≠ P_{state+1}
	      state ← π[state]
	if p_i ≠ P_{state+1}
	    state ← state + 1
	π[c] ← state





Suffixsortering
===============


Suffixträd


En trie med alla suffix till en sträng

Exempel "ananas"

	<< bild 1 >>

Några tillämpningar

-- Vad är längsta delsträng
   som förekommer ≥ t gånger?

-- Hur många delsträngar av längd ℓ förekommer i både T och T'


Bra:	Givet trådet kan många intressanta problem lösas i linjär tid (i trädets storlek)

Dåligt:	Väldigt komplicerade algoritmer



Suffix-array


Sortera suffix i alfabetisk ordning

0: ananas ⎫
1: nanas  ⎪
2: anas   ⎬=> 0, 2, 4, 1, 3, 5
3: nas    ⎪
4: as     ⎪
5: s      ⎭


Tumregel: Allt man kan göra med ett suffixträd kan
	  också göras med en suffix-array, gat en
	  faktor log n långsammare.


Naiv algoritm 𝓞(n² log n)

Viktigt: kan inte explicit skapa alla n suffix


Idéer:

∙ Sortera på de 2↑k första tecknen.

    (k = 0, 1, 2, 3, …, log n)

∙ När vi sorterar på prefix av längd 2↑k:

    -- Suffixen redan sorterade på de 2↑{k−1} första tecknen.
       Bildar grupper av suffix där 2↑{k−1} första tecknen är
       identiska.

    -- Vi behöver sortera varje grupp påde 2↑{k−1} nästföljande
       tecknen.
       Men fessa tecken äär de 2↑{k−1} första för några andra
       suffix; vi har redan deras ordning.


0: ananas ⎫    	2: a[n]as  ⎞ ⎫     2: an[as]  ⎞ ⎫     0: ananas)
1: nanas  ⎪k=0	4: a[s]    ⎟ ⎪k=1  0: an[an]as⎠ ⎪k=2  2: anas  )
2: anas   ⎬==>  0: a[n]anas⎠ ⎬==>  4: as[  ]  ) ⎬==>  4: as    ) klar, alla grupper
3: nas    ⎪	3: n[a]s   ⎞ ⎪     3: na[s ]  ⎞ ⎪     1: nanas ) består av ett element
4: as     ⎪	1: n[a]nas ⎠ ⎪     1: na[na]s ⎠ ⎪     3: nas   )
5: s      ⎭	5: s[ ]    ) ⎭     5: s [  ]  ) ⎭     5: s     )


Körtid

∙ log n iterationer
∙ i varje iteration sortera vi ≤ n element	𝓞(n log n) jämförelser
∙ varje jämförelse kan göras i 𝓞(1) tid
  genom att hålla reda på vilken position varje suffix finns på


Total tid: 𝓞(n log² n) 	  	 	  [log² n = (log n)²]

Inte den snabbaste, men enkel.





